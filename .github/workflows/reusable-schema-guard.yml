name: Reusable Schema Guard

on:
  workflow_call:
    inputs:
      include:
        required: true
        type: string
      exclude:
        required: false
        type: string
      annotate:
        required: false
        type: boolean
        default: true
      core_ref:
        required: false
        type: string
        default: main
      core_repo:              # allows swapping the core repository if needed
        required: false
        type: string
        default: zkpip/zkpip
      core_path:              # avoids hardcoding __core
        required: false
        type: string
        default: __core
    secrets:
      ORG_READ_TOKEN:
        required: false

jobs:
  guard:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      # 1) Checkout caller (consumer) repository
      - name: Checkout caller repo
        uses: actions/checkout@v4

      # 2) Prepare core repo under inputs.core_path
      #    Strategy:
      #      a) Try public HTTPS clone (works on forks if the repo is public)
      #      b) Fallback to token-based clone for internal runs
      - name: Prepare core into ${{ inputs.core_path }}
        shell: bash
        run: |
          set -euxo pipefail
          CORE_PATH="${{ inputs.core_path }}"
          CORE_REPO="${{ inputs.core_repo }}"
          CORE_REF="${{ inputs.core_ref }}"

          rm -rf "$CORE_PATH"

          # Public clone first
          git clone --depth 1 --branch "$CORE_REF" "https://github.com/${CORE_REPO}.git" "$CORE_PATH" || true

          # Token fallback (internal runs)
          if [ ! -f "$CORE_PATH/schemas/common.schema.json" ]; then
            echo "Public clone missing or schemas not found → retrying with token…"
            rm -rf "$CORE_PATH"
            git clone --depth 1 --branch "$CORE_REF" \
              "https://x-access-token:${{ secrets.ORG_READ_TOKEN || github.token }}@github.com/${CORE_REPO}.git" \
              "$CORE_PATH"
          fi

          # Fast diagnostics and early, clear failure if schemas are missing
          ls -la "$CORE_PATH" || true
          ls -la "$CORE_PATH/schemas" || true
          test -f "$CORE_PATH/schemas/common.schema.json" || { echo 'Missing schemas/common.schema.json in core repo'; exit 66; }

      # 3) Node.js toolchain
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      # 4) Build core CLI if dist is not versioned in the repo
      - name: Build core CLI if dist is absent
        shell: bash
        run: |
          set -euxo pipefail
          CORE_PATH="${{ inputs.core_path }}"
          if [ ! -d "$CORE_PATH/packages/core/dist" ]; then
            pushd "$CORE_PATH"
            npm ci --workspaces=false
            npm ci -w packages/core
            npm run build -w packages/core
            popd
          fi

      # 5) Export environment variables for downstream guard steps
      - name: Export env for guard
        shell: bash
        run: |
          echo "CORE_ROOT=${{ inputs.core_path }}" >> "$GITHUB_ENV"
          echo "INCLUDE_GLOBS<<EOF" >> "$GITHUB_ENV"
          echo "${{ inputs.include }}" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"
          echo "EXCLUDE_GLOBS<<EOF" >> "$GITHUB_ENV"
          echo "${{ inputs.exclude }}" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"
          echo "ANNOTATE=${{ inputs.annotate }}" >> "$GITHUB_ENV"

      # 6) Run your existing guard logic (AJV, CLI, etc.). It can rely on CORE_ROOT, INCLUDE_GLOBS, EXCLUDE_GLOBS, ANNOTATE.
      - name: Run Schema Guard
        shell: bash
        run: |
          set -euxo pipefail
          echo "Running Schema Guard with CORE_ROOT=$CORE_ROOT"
          # Example placeholder – replace with your actual guard command:
          node -e "console.log('Schema guard would run here with', process.env.CORE_ROOT, process.env.INCLUDE_GLOBS)"
