name: Reusable Schema Guard

on:
  workflow_call:
    inputs:
      paths:
        description: 'Comma-separated glob patterns for files to validate'
        required: true
        type: string
      exclude:
        description: 'Comma- or newline-separated glob patterns to exclude'
        required: false
        default: ''
        type: string
      annotate:
        description: 'Emit GitHub error annotations for failing files'
        required: false
        default: false
        type: boolean        
    secrets:
      ORG_READ_TOKEN:
        description: 'Fine-grained PAT with Contents: Read for the zkpip/zkpip repo'
        required: true

permissions:
  contents: read

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout consumer repository
        uses: actions/checkout@v4

      - name: Checkout core schema repository
        uses: actions/checkout@v4
        with:
          repository: zkpip/zkpip
          ref: ${{ github.ref }} # same tag/branch as the consumer repo
          token: ${{ secrets.ORG_READ_TOKEN }}
          path: __core

      - name: Build core validator
        run: |
          npm ci --prefix __core
          npm run build --prefix __core/packages/core

      # Collect matching files using shell (no npm install in the consumer repo)
      - name: Collect matching files
        id: collect
        shell: bash
        env:
          GLOBS: ${{ inputs.paths }}
          EXCLUDES: ${{ inputs.exclude }}
        run: |
          set -euo pipefail

          # ---- Includes (always produce file, even if empty)
          : > .schema_includes.raw
          while IFS= read -r pat; do
            [[ -z "$pat" ]] && continue
            git ls-files "$pat" 2>/dev/null >> .schema_includes.raw || true
          done < <(printf "%s" "$GLOBS" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | awk 'NF')

          sort -u .schema_includes.raw > .schema_includes.txt || true
          touch .schema_includes.txt

          if [[ -s .schema_includes.txt ]]; then
            echo "Includes:"
            cat .schema_includes.txt
          else
            echo "No files matched include patterns."
          fi

          # ---- Excludes (optional; same strategy; always produce files)
          : > .schema_files.txt
          if [[ -n "${EXCLUDES// /}" ]]; then
            : > .schema_excludes.raw
            while IFS= read -r xpat; do
              [[ -z "$xpat" ]] && continue
              git ls-files "$xpat" 2>/dev/null >> .schema_excludes.raw || true
            done < <(printf "%s" "$EXCLUDES" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | awk 'NF')

            sort -u .schema_excludes.raw > .schema_excludes.txt || true
            touch .schema_excludes.txt

            # set difference: includes \ excludes  (mindkettő rendezett)
            comm -23 .schema_includes.txt .schema_excludes.txt > .schema_files.txt || true
          else
            cp .schema_includes.txt .schema_files.txt
          fi

          echo "Final file list for validation (may be empty):"
          cat .schema_files.txt || true

          {
            echo 'FILES<<EOF'
            cat .schema_files.txt
            echo 'EOF'
          } >> "$GITHUB_ENV"

      - name: Run schema validation
        shell: bash
        env:
          ANNOTATE: ${{ inputs.annotate }}        
        run: |
          set -euo pipefail
          if [[ ! -s .schema_files.txt ]]; then
            echo "No files to validate after filters. Exiting 0."
            exit 0
          fi        
          node -e "
            const { validateFileBatch } = require('./__core/packages/core/dist/cli/validate.js');
            const files = (process.env.FILES || '').split('\n').filter(Boolean);
            (async () => {
              if (!files.length) {
                console.log('No files matched');
                process.exit(0);
              }
              const { failed } = await validateFileBatch(files);
              if (failed.length) {
                if (process.env.ANNOTATE === 'true') {
                  for (const f of failed) {
                    const file = typeof f === 'string' ? f : (f.file || f.path || '');
                    const msg = (typeof f === 'object' && f.message) ? f.message : 'Schema validation failed';
                    if (file) console.log('::error file=' + file + '::' + msg);
                    else console.log('::error::' + msg);
                  }
                }              
                console.error('Invalid files:', failed);
                process.exit(1);
              }
              console.log('All files are schema-valid ✅');
            })().catch(e => { console.error(e); process.exit(1); });
          "