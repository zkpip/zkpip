# zkpip/zkpip/.github/workflows/reusable-schema-guard.yml
name: Reusable Schema Guard

on:
  workflow_call:
    inputs:
      include:
        required: true
        type: string
      exclude:
        required: false
        type: string
      annotate:
        required: false
        type: boolean
        default: true
      core_ref:
        required: false
        type: string
        default: main
      core_repo:
        required: false
        type: string
        default: zkpip/zkpip
      core_path:
        required: false
        type: string
        default: __core
    secrets:
      ORG_READ_TOKEN:
        required: false

jobs:
  guard:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      # 1) Checkout the caller repository
      - name: Checkout caller repo
        uses: actions/checkout@v4

      # 2) Clone core under core_path (public clone first, then token fallback)
      - name: Prepare core into ${{ inputs.core_path }}
        shell: bash
        run: |
          set -euxo pipefail
          CORE_PATH="${{ inputs.core_path }}"
          CORE_REPO="${{ inputs.core_repo }}"
          CORE_REF="${{ inputs.core_ref }}"
          rm -rf "$CORE_PATH"

          # Public HTTPS clone (works on forks if the repo is public)
          git clone --depth 1 --branch "$CORE_REF" "https://github.com/${CORE_REPO}.git" "$CORE_PATH" || true

          # Token fallback (internal runs)
          if [ ! -d "$CORE_PATH" ] || [ ! -d "$CORE_PATH/schemas" ]; then
            echo "Public clone missing → retrying with token…"
            rm -rf "$CORE_PATH"
            git clone --depth 1 --branch "$CORE_REF" \
              "https://x-access-token:${{ secrets.ORG_READ_TOKEN || github.token }}@github.com/${CORE_REPO}.git" \
              "$CORE_PATH"
          fi

          # Minimal schema presence check (do NOT check for old common.schema.json)
          ls -la "$CORE_PATH/schemas" || true
          if ! ls "$CORE_PATH"/schemas/*.schema.json >/dev/null 2>&1; then
            echo "No *.schema.json files found under $CORE_PATH/schemas"
            exit 66
          fi

      # 3) Setup Node with cache (internal runs)     
      - name: Setup Node (with npm cache)
        if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false }}
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            ${{ inputs.core_path }}/package-lock.json
            ${{ inputs.core_path }}/packages/**/package-lock.json

      # Fork PRs → no cache
      - name: Setup Node (no cache on forks)
        if: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == true }}
        uses: actions/setup-node@v4
        with:
          node-version: 20

      # 4) Force a clean build of the core CLI (avoid stale dist referencing old filenames)
      - name: Clean & build core CLI
        shell: bash
        run: |
          set -euxo pipefail
          CORE_PATH="${{ inputs.core_path }}"
          rm -rf "$CORE_PATH/packages/core/dist"
          pushd "$CORE_PATH"
          npm ci --workspaces=false --no-audit --no-fund
          npm ci -w packages/core --no-audit --no-fund
          npm run build -w packages/core
          popd

      # 5) Safe hotfix: if dist still refers to old 'schemas/common.schema.json', rewrite to 'schemas/mvs.core.schema.json'
      - name: Patch dist paths if legacy 'common.schema.json' is referenced
        shell: bash
        run: |
          set -euxo pipefail
          CORE_PATH="${{ inputs.core_path }}"
          COMMON="$CORE_PATH/schemas/common.schema.json"
          MVSCORE="$CORE_PATH/schemas/mvs.core.schema.json"

          if [ ! -f "$COMMON" ] && [ -f "$MVSCORE" ]; then
            if grep -R "schemas/common.schema.json" -n "$CORE_PATH/packages/core/dist" >/dev/null 2>&1; then
              sed -i 's#schemas/common.schema.json#schemas/mvs.core.schema.json#g' "$CORE_PATH/packages/core/dist/cli/"*.js || true
            fi
          fi

      # 6) Export envs for the guard run
      - name: Export env for guard
        shell: bash
        run: |
          echo "CORE_ROOT=${{ inputs.core_path }}" >> "$GITHUB_ENV"
          {
            echo "INCLUDE_GLOBS<<EOF"
            echo "${{ inputs.include }}"
            echo "EOF"
          } >> "$GITHUB_ENV"
          {
            echo "EXCLUDE_GLOBS<<EOF"
            echo "${{ inputs.exclude }}"
            echo "EOF"
          } >> "$GITHUB_ENV"
          echo "ANNOTATE=${{ inputs.annotate }}" >> "$GITHUB_ENV"

      # 7) Run the actual guard (replace with your real command)
      - name: Run Schema Guard
        shell: bash
        run: |
          set -euxo pipefail
          echo "Running Schema Guard with CORE_ROOT=$CORE_ROOT"
          # Example placeholder:
          node -e "console.log('Schema guard running with', process.env.CORE_ROOT, process.env.INCLUDE_GLOBS)"